#include<iostream>
#include<cstdio>
#include<cstdlib>  // 使用free()函数需要包含这个库，用于释放动态分配的内存空间

using namespace std;

// 定义全局变量，m用于表示链表中节点的总数，n用于表示某种操作的计数相关参数（从后续逻辑看与删除节点相关）
int m, n;  
// 定义链表节点结构体，包含一个数据域data用于存储数据，以及一个指针域next用于指向下一个节点
struct Node {  
    int data;
    Node *next;
};

// 定义链表的头指针head，以及用于操作链表的临时指针p、尾指针tail和辅助指针temp
Node *head, *p, *tail, *temp;  

int main() {
    // 通过scanf函数获取用户输入的两个整数，分别赋值给m和n，用于后续链表操作的相关参数设定
    scanf("%d%d", &m, &n);  

    // 动态分配内存创建链表的头节点，使头节点的next指针初始化为NULL，表示链表暂时为空
    head = new Node;  
    head->next = NULL;
    // 初始化时，尾指针tail也指向头节点，因为此时链表只有头节点这一个元素
    tail = head;  

    // 通过循环创建包含m个节点的链表，每个节点的数据域存储从1到m的连续整数
    for (int i = 1; i <= m; i++) {  
        // 动态分配内存创建一个新的节点
        p = new Node;  
        // 将新节点的数据域赋值为当前循环的序号i，也就是依次存储1到m的数字
        p->data = i;  
        // 将新节点的next指针置为NULL，因为它暂时是链表末尾的节点
        p->next = NULL;  
        // 将当前尾节点（tail）的next指针指向新创建的节点p，把新节点链接到链表末尾
        tail->next = p;  
        // 更新尾节点指针tail，使其指向新的链表末尾节点，即刚创建的节点p
        tail = p;  
    }

    // 让指针p指向链表的第一个有效节点（头节点后的第一个节点），因为头节点通常不存储实际数据，只是作为链表的起始标识
    p = head->next;  
    // 将链表尾节点的next指针指向头节点的下一个节点，也就是让链表形成环形链表结构
    tail->next = head->next;  

    // 外层循环控制整体的操作次数，这里总共会执行m次，每次操作会删除一个节点
    for (int i = 1; i <= m; i++) {  
        // 内层循环用于定位到要删除节点的前一个节点，每次循环让p指针向后移动n - 1个节点位置
        for (int j = 1; j < n - 1; j++) {  
            p = p->next;
        }

        // 输出当前要删除节点的下一个节点的数据域的值，也就是要删除节点后面那个节点存储的数据
        printf("%d ", p->next->data);  

        // 用临时指针temp记录当前要删除的节点（即p指针指向节点的下一个节点）
        temp = p->next;  
        // 将p指针指向节点的next指针绕过要删除的节点，直接指向要删除节点的下一个节点，实现从链表中移除要删除的节点
        p->next = temp->next;  
        // 更新指针p，使其指向刚才绕过的那个节点（也就是原本要删除节点的下一个节点），方便下一轮循环操作
        p = p->next;  
        // 释放要删除节点（temp指向的节点）所占用的内存空间，避免内存泄漏
        free(temp);  
    }
    printf("\n");
    return 0;
}